// 使用贪心法的思路，每次跳跃最大的距离，看看是否可以到达终点。
//
// 显然，可能有存在合法路径但每次跳跃最大距离无法到达终点的情况，比如 [3,2,1,0,4]。
//
// 每次跳跃最大距离却无法到达终点的根源在于，贪心算法缺乏“前视”，跳到当前一步能
// 跳到的最远的位置，但这个位置可能只能跳很短的距离。
//
// 为了解决贪心法短视的问题，必须将一步之后的位置上能跳跃的距离也考虑在内。最直
// 接的办法是回溯，尝试所有可能的路径，如果成功则终止流程，否则回溯。
//
// 实际上，考虑在跳跃距离为 N 的位置跳跃几步是无意义的，关键在于在该位置最远可以
// 条到哪。1）在一个位置上，计算得到该位置能够跳跃到的最远的位置（覆盖范围）；2)
// 然后再从下一个位置出发，计算该位置能够跳跃到的最远距离；以此类推。能否到达终点
// 转化为范围是否可以覆盖到终点。
//
// 流程终止条件：
//   1. 当前位置超出覆盖范围，说明能跳到的最远位置的跳跃距离为 0，不可以再跳跃。
//      比如 [3,2,1,0,4]。实际上，只有能跳到的最远位置的跳跃距离为 0 才无法到达
//      终点。试想每个位置的跳跃距离都为 1，一步一步跳必定能到达终点。
//   2. 覆盖范围覆盖终点，说明可以到达终点。
//
class Solution {
public:
  bool canJump(vector<int> &nums) {
    int end = 0;
    for (int pos = 0; pos <= end && end < nums.size(); ++pos) {
      if (pos + nums[pos] > end) {
        end = pos + nums[pos];
      }
    }
    return end >= nums.size() - 1;
  }
};
