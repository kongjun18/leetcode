// 将数组分成 3 部分，分别为 A、B、C，其中 A 和 C 已经是升序的，其中 B 是最短无
// 序子数组。
//
// 因为对 B 排序后，整个数组升序，因此 B 的最小值一定大于 A 的最大值，B 的最大值
// 一定小于 C 的最小值。
//
// 将数组画成图高度表示值，可以发现除了 B，其他两个数组的值是一条斜线（单调）。
// 在 B 中，最小值一定不在 B 左边界，因为如果在左边界，则其最小值大于 A 的最大值，
// 直接把这个值放入到 A 中，B 的长度更短。同理，B 的最大值一定不再 B 的右边界。
//
// B 的最大值、最小值一定在 B 的中间区域。
//
//             |
//        right|
//   --------|||
//        |  |||
//   left||| |||
//   ---||||||||
//     |||||||||
//    ||||||||||
//   |||||||||||
//
// B 的最大值大于右边界及其左边所有的值，但小于右边界所有的值。从往右扫描数组，若
// 当前值大于最大值，则更新最大值，否则将此下标记为 B 的右边界，最后记录的边界就
// 是正确的右边界。超过右边界后，所有的值都大于最大值，所以不会更新右边界。
//
// B 的最小值小于左边界及其右边所有的值，但大于左边界所有的值。从左往右扫描数组，
// 若当前值小于最小值，则更新最小值，否则将此下标记为 B 的左边界，最后记录的边界
// 就是正确的左边界。
class Solution {
public:
  int findUnsortedSubarray(vector<int> &nums) {
    int min = INT_MAX;
    int max = INT_MIN;
    int left = 0;
    int right = 0;
    for (int i = 0; i < nums.size(); ++i) {
      if (max > nums[i]) {
        right = i;
      } else {
        max = nums[i];
      }
      if (min < nums[nums.size() - i - 1]) {
        left = nums.size() - i - 1;
      } else {
        min = nums[nums.size() - i - 1];
      }
    }
    return right - left + 1 - (left == right);
  }
};
