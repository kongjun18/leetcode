// 解题方法
// - 求重叠区间
// - 贪心算法
//
// 这道题显然使用贪心算法解决，并且思路也很清晰，贪心贪的是“一箭射中尽可能多的
// 重叠的气球”。
//
// 难点在于“如何确保一箭射中尽可能夺得重叠的气球”。显然，重叠的气球可以抽象为“区
// 间问题”，一个个重叠的气球就是一个个重叠的区间。
//
// 如果两气球不重叠，那么每个气球都需要一箭；如果两气球重叠，那么只需
// 要一箭就可以引爆两个气球。
//
// 最直接的思路就是找到能够射中尽可能多的重叠气球的位置，在此位置射箭，然后再在
// 下一个位置射箭。在这样想的时候已经走入了误区，题目要求的是用最少的箭引爆气球，
// 如果使用这种思路，实际上将题目转换为“找到一个能用最少的箭引爆气球的射箭位置
// 的序列”，这增大了问题的难度。算法应该从更宽松的条件出发，从中获取灵感，进而
// 得到更加严格的情况下的解。即使要求射箭位置，也应该是解决如何用最少的箭引爆气
// 球的问题。
//
// 根据气球的左边界排序，这样只需要判断右边的气球的左边界是否大于左边气球的右边
// 界就可以知道两气球是否重叠。如果气球重叠，那么就取两气球右边界的最小值作为气
// 球新的右边界，这样就相当于不断缩小重叠区间，这个区间能尽可地让更多的气球覆盖
// 到（覆盖到意味着这些气球都重叠了）。如果发现有气球不重叠，由于气球按左边界排
// 序，后面的气球必然也不和前面的气球重叠，因此必须要再射出一箭。
class Solution {
public:
  int findMinArrowShots(vector<vector<int>> &points) {
    if (points.size() == 0) {
      return 0;
    }
    sort(points.begin(), points.end(),
         [](const auto &lhs, const auto &rhs) { return lhs[0] < rhs[0]; });
    int result = 1;
    for (int i = 1; i < points.size(); ++i) {
      if (points[i][0] > points[i - 1][1]) {
        ++result;
      } else { // 缩短重叠区间
        points[i][1] = min(points[i][1], points[i - 1][1]);
      }
    }
    return result;
  }
};
